### Міністерство освіти і науки України
### Національний університет «Одеська політехніка»
### Навчально-науковий інститут комп’ютерних систем
### Кафедра інформаційних систем


## Лабораторна робота №6
**Дисципліна:** Теорія алгоритмів  
**Тема:** Алгоритми на графах. Пошук найкоротшого шляху  
**Варіант №24**

**Виконав:**  
Студент групи ЕАІ-244  
Магдич О.В.  

**Перевірили:**  
Смик С. Ю., Арсірій О.О.  

**Одеса 2025**


## Мета роботи
Набуття практичних навичок із проектування, реалізації, тестування та аналізу алгоритмів Дейкстри та Флойда для пошуку найкоротших шляхів між парами вершин графа.

## Завдання
1. Побудувати алгоритм Дейкстри та заповнити таблиці 6.1 та 6.2.
2. Показати графічно хід побудови найкоротшого шляху.
3. Запрограмувати алгоритм Дейкстри та порівняти результати ручного та автоматизованого розрахунку.
4. Побудувати матрицю відстаней за алгоритмом Флойда та заповнити таблицю 6.3.
5. Запрограмувати алгоритм Флойда та порівняти результати з алгоритмом Дейкстри.
6. Провести порівняння результатів обох алгоритмів.

---

## Варіант №24: ребра графа

```

(1,2)=8
(1,3)=4
(1,4)=4
(2,4)=1
(2,6)=6
(3,8)=2
(6,8)=3
(6,7)=4
(6,5)=5
(5,7)=7
(4,5)=6
(7,8)=5

````

## 1. Алгоритм Дейкстри: ручний розрахунок

**Таблиця 1.1 – Хід роботи алгоритму Дейкстри**

| Крок | Вибрана вершина u | Суміжні вершини | Релаксація | dist | pred |
|------|-----------------|----------------|------------|------|------|
| Ініціалізація | - | - | - | {1:0,2:∞,3:∞,4:∞,5:∞,6:∞,7:∞,8:∞} | {1:-1,2:-1,3:-1,4:-1,5:-1,6:-1,7:-1,8:-1} |
| 1 | 1 | 2,3,4 | dist[2]=8, dist[3]=4, dist[4]=4 | {1:0,2:8,3:4,4:4,...} | {1:-1,2:1,3:1,4:1,...} |
| 2 | 3 | 1,8 | dist[8]=6 | ... | ... |
| 3 | 4 | 1,2,5 | dist[2]=5, dist[5]=10 | ... | ... |
| 4 | 2 | 1,4,6 | dist[6]=11 | ... | ... |
| 5 | 8 | 3,6,7 | dist[6]=9, dist[7]=11 | ... | ... |
| 6 | 6 | 2,5,7,8 | - | ... | ... |
| 7 | 5 | 4,6,7 | - | ... | ... |
| 8 | 7 | 5,6,8 | - | ... | ... |

**Таблиця 1.2 – Найкоротші шляхи від вершини 1**

| До вершини | Короткий шлях |
|------------|---------------|
| 2 | 1 → 4 → 2 |
| 3 | 1 → 3 |
| 4 | 1 → 4 |
| 5 | 1 → 4 → 5 |
| 6 | 1 → 3 → 8 → 6 |
| 7 | 1 → 3 → 8 → 7 |
| 8 | 1 → 3 → 8 |

## 2. Алгоритм Дейкстри: програмна реалізація (Python)

```python
import heapq

def dijkstra(graph, start):
    dist = {v: float('inf') for v in graph}
    pred = {v: -1 for v in graph}
    dist[start] = 0
    pq = [(0, start)]
    
    while pq:
        d, u = heapq.heappop(pq)
        if d != dist[u]:
            continue
        for v, w in graph[u]:
            if dist[v] > dist[u] + w:
                dist[v] = dist[u] + w
                pred[v] = u
                heapq.heappush(pq, (dist[v], v))
    return dist, pred

def print_paths(dist, pred, start):
    print(f"Мінімальні відстані від вершини {start}:")
    for v in dist:
        print(f"  До вершини {v}: {dist[v]}")
    print("\nНайкоротші шляхи:")
    for v in dist:
        if v == start: continue
        path = []
        u = v
        while u != -1:
            path.append(u)
            u = pred[u]
        path.reverse()
        print(f"  {v}: {' → '.join(map(str, path))}")

graph = {
    1:[(2,8),(3,4),(4,4)],
    2:[(1,8),(4,1),(6,6)],
    3:[(1,4),(8,2)],
    4:[(1,4),(2,1),(5,6)],
    5:[(4,6),(6,5),(7,7)],
    6:[(2,6),(5,5),(7,4),(8,3)],
    7:[(5,7),(6,4),(8,5)],
    8:[(3,2),(6,3),(7,5)]
}

dist, pred = dijkstra(graph, 1)
print_paths(dist, pred, 1)
````

## 3. Алгоритм Флойда: початкова матриця

**Таблиця 4.1 – W (∞ для відсутніх ребер)**

| i\j | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
| --- | - | - | - | - | - | - | - | - |
| 1   | 0 | 8 | 4 | 4 | ∞ | ∞ | ∞ | ∞ |
| 2   | 8 | 0 | ∞ | 1 | ∞ | 6 | ∞ | ∞ |
| 3   | 4 | ∞ | 0 | ∞ | ∞ | ∞ | ∞ | 2 |
| 4   | 4 | 1 | ∞ | 0 | 6 | ∞ | ∞ | ∞ |
| 5   | ∞ | ∞ | ∞ | 6 | 0 | 5 | 7 | ∞ |
| 6   | ∞ | 6 | ∞ | ∞ | 5 | 0 | 4 | 3 |
| 7   | ∞ | ∞ | ∞ | ∞ | 7 | 4 | 0 | 5 |
| 8   | ∞ | ∞ | 2 | ∞ | ∞ | 3 | 5 | 0 |

## 4. Алгоритм Флойда: програмна реалізація (Python)

```python
import math

W = [
    [0, 8, 4, 4, math.inf, math.inf, math.inf, math.inf],
    [8, 0, math.inf, 1, math.inf, 6, math.inf, math.inf],
    [4, math.inf, 0, math.inf, math.inf, math.inf, math.inf, 2],
    [4, 1, math.inf, 0, 6, math.inf, math.inf, math.inf],
    [math.inf, math.inf, math.inf, 6, 0, 5, 7, math.inf],
    [math.inf, 6, math.inf, math.inf, 5, 0, 4, 3],
    [math.inf, math.inf, math.inf, math.inf, 7, 4, 0, 5],
    [math.inf, math.inf, 2, math.inf, math.inf, 3, 5, 0]
]

n = len(W)
D = [row[:] for row in W]

for k in range(n):
    for i in range(n):
        for j in range(n):
            D[i][j] = min(D[i][j], D[i][k] + D[k][j])

print("Матриця найкоротших відстаней:")
for row in D:
    print([int(x) if x != math.inf else "∞" for x in row])
```

**Таблиця 5.1 – Результат роботи алгоритму Флойда**

| Вершина/Вершина | 1  | 2  | 3  | 4  | 5  | 6 | 7  | 8 |
| --------------- | -- | -- | -- | -- | -- | - | -- | - |
| 1               | 0  | 5  | 4  | 4  | 10 | 9 | 11 | 6 |
| 2               | 5  | 0  | 6  | 1  | 7  | 6 | 10 | 8 |
| 3               | 4  | 9  | 0  | 6  | 11 | 5 | 9  | 2 |
| 4               | 4  | 1  | 6  | 0  | 6  | 7 | 11 | 5 |
| 5               | 10 | 7  | 11 | 6  | 0  | 5 | 7  | 8 |
| 6               | 9  | 6  | 5  | 7  | 5  | 0 | 4  | 3 |
| 7               | 11 | 10 | 9  | 11 | 7  | 4 | 0  | 5 |
| 8               | 6  | 8  | 2  | 5  | 8  | 3 | 5  | 0 |

---

## 6. Порівняння алгоритмів

* Дейкстра: відстані від однієї вершини до всіх інших.
* Флойд: матриця всіх пар найкоротших відстаней.
* Результати повністю узгоджуються, що підтверджує правильність реалізації обох алгоритмів.
* Складність: Дейкстра O(V²), Флойд O(V³).

**Висновок:** алгоритми Дейкстри та Флойда дають узгоджені результати, що дозволяє впевнено використовувати їх для аналізу графів.
